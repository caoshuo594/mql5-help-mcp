<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
  <title>2.6.2. Arithmetic type conversions</title>
  <meta name="keywords" content="" />
  <link type="text/css" href="default.css" rel="stylesheet" />

   <script type="text/javascript" src="jquery.js"></script>
   <script type="text/javascript" src="helpman_settings.js"></script>
   <script type="text/javascript" src="helpman_topicinit.js"></script>


</head>

<body style="background-color:#FFFFFF; font-family:'Trebuchet MS',Tahoma,Arial,Helvetica,sans-serif; margin:0px;">



<table width="100%" height="49"  border="0" cellpadding="0" cellspacing="0" style="margin-top:0px; background-color:#1660af;">
  <tr>
    <td></td>
    <td valign="middle">
      <table style="margin-top:4px; margin-bottom:5px;" width="100%"  border="0" cellspacing="0" cellpadding="5">
        <tr valign="middle">
          <td class="nav">
<a class="h_m" href="index.htm">          MQL5 Programming for Traders </a> / <a class="h_m" href="part2.htm"> Part 2. Programming fundamentals </a> / <a class="h_m" href="2_6_conversion.htm"> 2.6 Type conversion </a>/ 2.6.2. Arithmetic type conversions
          </td>
          <td width="70" align="right">
          <a href="2_6_1_conversion_implicit.htm"><img style="vertical-align:middle;" src="previous.png" alt="?????" width="27" height="27" border=0></a>&nbsp;
          <a href="2_6_3_conversion_explicit.htm"><img style="vertical-align:middle;" src="next.png" alt="??????" width="27" height="27" border="0"></a>
          </td>
        </tr>
      </table>
    </td>
    <td width="5"></td>
  </tr>
</table>



<div id="help">
<p class="p_H3"><span class="f_H3">2.6.2. Arithmetic type conversions</span></p>
<p class="p_Text"><span class="f_Text">In arithmetic calculation and comparison expressions, values of different types are often used as operands. To process them correctly, it is necessary to bring the types to a certain &quot;common denominator&quot;. The compiler attempts to do this without the programmer's intervention unless the programmer has specified explicit conversion rules (see <a href="2_6_3_conversion_explicit.htm" class="topiclink">Explicit type conversion</a>). In this case, the compiler, whenever possible, tries to preserve the maximum precision when it comes to numbers. In particular, it produces an increase in the capacity of integer numbers and the transition from integer to real numbers (if they are involved).</span></p>
<p class="p_Text"><span class="f_Text">Integer expansion implies conversion of </span><span class="f_Text" style="font-style: italic;">bool</span><span class="f_Text">, </span><span class="f_Text" style="font-style: italic;">char</span><span class="f_Text">, </span><span class="f_Text" style="font-style: italic;">unsigned char</span><span class="f_Text">, </span><span class="f_Text" style="font-style: italic;">short</span><span class="f_Text">, </span><span class="f_Text" style="font-style: italic;">unsigned short</span><span class="f_Text"> to </span><span class="f_Text" style="font-style: italic;">int</span><span class="f_Text"> (or </span><span class="f_Text" style="font-style: italic;">unsigned int</span><span class="f_Text"> if </span><span class="f_Text" style="font-style: italic;">int</span><span class="f_Text"> isn't big enough to store specific numbers). Large values can be converted to </span><span class="f_Text" style="font-style: italic;">long</span><span class="f_Text"> and </span><span class="f_Text" style="font-style: italic;">unsigned long</span><span class="f_Text">.</span></p>
<p class="p_Text"><span class="f_Text">If the type of the variable is not able to store the result of the type that was obtained when the expression was evaluated, the compiler will issue a warning:</span></p>
<div style="text-align: left; text-indent: 0; line-height: 1.0; page-break-inside: avoid; page-break-after: avoid; border-color: #d8dfea; border-style: solid; border-width: thin; background: #fbf9f5; padding: 0 0 0 0; margin: 2px 17px 2px 17px;"><table cellspacing="0" cellpadding="3" border="0" style="text-align: justify;border:none; border-spacing:0;">
<tr>
<td style="vertical-align:top; padding:3px; border:none"><p class="p_CodeExample" style="page-break-inside: avoid; page-break-after: avoid;"><span class="f_CodeExample" style="color: #0000ff;">double</span><span class="f_CodeExample">&nbsp;</span><span class="f_CodeExample" style="color: #333333;">d</span><span class="f_CodeExample">&nbsp;=&nbsp;</span><span class="f_CodeExample" style="color: #333333;">1</span><span class="f_CodeExample">.</span><span class="f_CodeExample" style="color: #333333;">0</span><span class="f_CodeExample">;</span>
<br><span class="f_CodeExample" style="color: #0000ff;">int</span><span class="f_CodeExample">&nbsp;</span><span class="f_CodeExample" style="color: #333333;">x</span><span class="f_CodeExample">&nbsp;=&nbsp;</span><span class="f_CodeExample" style="color: #333333;">1</span><span class="f_CodeExample">.</span><span class="f_CodeExample" style="color: #333333;">0</span><span class="f_CodeExample">&nbsp;/&nbsp;</span><span class="f_CodeExample" style="color: #333333;">10</span><span class="f_CodeExample">;&nbsp;</span><span class="f_CodeExample" style="color: #808080;">//&nbsp;truncation&nbsp;of&nbsp;constant&nbsp;value</span>
<br><span class="f_CodeExample" style="color: #0000ff;">int</span><span class="f_CodeExample">&nbsp;</span><span class="f_CodeExample" style="color: #333333;">y</span><span class="f_CodeExample">&nbsp;=&nbsp;</span><span class="f_CodeExample" style="color: #333333;">d</span><span class="f_CodeExample">&nbsp;/&nbsp;</span><span class="f_CodeExample" style="color: #333333;">10</span><span class="f_CodeExample">;&nbsp;&nbsp;&nbsp;</span><span class="f_CodeExample" style="color: #808080;">//&nbsp;possible&nbsp;loss&nbsp;of&nbsp;data&nbsp;due&nbsp;to&nbsp;type&nbsp;conversion</span></p>
</td>
</tr>
</table>
</div>
<p class="p_Text"><span class="f_Text">The expression to initialize the variables </span><span class="f_Text" style="font-style: italic;">x</span><span class="f_Text"> and </span><span class="f_Text" style="font-style: italic;">y</span><span class="f_Text"> contains the real number 1.0, so the other operands (constant 10 in this case) are converted to </span><span class="f_Text" style="font-style: italic;">double</span><span class="f_Text">, and the result of division will also be of type </span><span class="f_Text" style="font-style: italic;">double</span><span class="f_Text">. However, the type of variables is </span><span class="f_Text" style="font-style: italic;">int</span><span class="f_Text">, and therefore an implicit conversion to it takes place.</span></p>
<p class="p_Text"><span class="f_Text">Calculation 1.0 / 10 is done by the compiler during compilation and therefore it gets a constant of type </span><span class="f_Text" style="font-style: italic;">double</span><span class="f_Text"> (0.1). Of course, in practice, it is unlikely that the initializing constant will exceed the size of the receiving variable. Therefore, the compiler warning &quot;truncation of constant value&quot; can be considered exotic. It just shows the problem in the most simplified way.</span></p>
<p class="p_Text"><span class="f_Text">However, as a result of variable-based calculations, similar data loss can also occur. The second compiler warning we see here (&quot;possible loss of data due to type conversion&quot;) occurs much more frequently. Moreover, the loss is possible not only when converting from real type to integer, but also vice versa.</span></p>
<div style="text-align: left; text-indent: 0; line-height: 1.0; page-break-inside: avoid; page-break-after: avoid; border-color: #d8dfea; border-style: solid; border-width: thin; background: #fbf9f5; padding: 0 0 0 0; margin: 2px 17px 2px 17px;"><table cellspacing="0" cellpadding="3" border="0" style="text-align: justify;border:none; border-spacing:0;">
<tr>
<td style="vertical-align:top; padding:3px; border:none"><p class="p_CodeExample" style="page-break-inside: avoid; page-break-after: avoid;"><span class="f_CodeExample" style="color: #0000ff;">double</span><span class="f_CodeExample">&nbsp;</span><span class="f_CodeExample" style="color: #333333;">f</span><span class="f_CodeExample">&nbsp;=&nbsp;</span><span class="f_CodeExample" style="color: #ff0000;">LONG_MAX</span><span class="f_CodeExample">;&nbsp;</span><span class="f_CodeExample" style="color: #808080;">//&nbsp;truncation&nbsp;of&nbsp;constant&nbsp;value</span>
<br><span class="f_CodeExample" style="color: #0000ff;">long</span><span class="f_CodeExample">&nbsp;</span><span class="f_CodeExample" style="color: #333333;">m1</span><span class="f_CodeExample">&nbsp;=&nbsp;</span><span class="f_CodeExample" style="color: #333333;">1000000000</span><span class="f_CodeExample">;</span>
<br><span class="f_CodeExample" style="color: #333333;">f</span><span class="f_CodeExample">&nbsp;=&nbsp;</span><span class="f_CodeExample" style="color: #333333;">m1</span><span class="f_CodeExample">&nbsp;*&nbsp;</span><span class="f_CodeExample" style="color: #333333;">m1</span><span class="f_CodeExample">;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="f_CodeExample" style="color: #808080;">//&nbsp;possible&nbsp;loss&nbsp;of&nbsp;data&nbsp;due&nbsp;to&nbsp;type&nbsp;conversion</span></p>
</td>
</tr>
</table>
</div>
<p class="p_Text"><span class="f_Text">As we know, type </span><span class="f_Text" style="font-style: italic;">double</span><span class="f_Text"> cannot accurately represent large integers (although its range of valid values is much larger than </span><span class="f_Text" style="font-style: italic;">long</span><span class="f_Text">).</span></p>
<p class="p_Text"><span class="f_Text">Another warning we might encounter due to type mismatch: &quot;integral constant overflow&quot;.</span></p>
<div style="text-align: left; text-indent: 0; line-height: 1.0; page-break-inside: avoid; page-break-after: avoid; border-color: #d8dfea; border-style: solid; border-width: thin; background: #fbf9f5; padding: 0 0 0 0; margin: 2px 17px 2px 17px;"><table cellspacing="0" cellpadding="3" border="0" style="text-align: justify;border:none; border-spacing:0;">
<tr>
<td style="vertical-align:top; padding:3px; border:none"><p class="p_CodeExample" style="page-break-inside: avoid; page-break-after: avoid;"><span class="f_CodeExample" style="color: #0000ff;">long</span><span class="f_CodeExample">&nbsp;</span><span class="f_CodeExample" style="color: #333333;">m1</span><span class="f_CodeExample">&nbsp;=&nbsp;</span><span class="f_CodeExample" style="color: #333333;">1000000000</span><span class="f_CodeExample">;</span>
<br><span class="f_CodeExample" style="color: #0000ff;">long</span><span class="f_CodeExample">&nbsp;</span><span class="f_CodeExample" style="color: #333333;">m2</span><span class="f_CodeExample">&nbsp;=&nbsp;</span><span class="f_CodeExample" style="color: #333333;">m1</span><span class="f_CodeExample">&nbsp;*&nbsp;</span><span class="f_CodeExample" style="color: #333333;">m1</span><span class="f_CodeExample">;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="f_CodeExample" style="color: #808080;">//&nbsp;ok:&nbsp;m2&nbsp;=&nbsp;1000000000000000000</span>
<br><span class="f_CodeExample" style="color: #0000ff;">long</span><span class="f_CodeExample">&nbsp;</span><span class="f_CodeExample" style="color: #333333;">m3</span><span class="f_CodeExample">&nbsp;=&nbsp;</span><span class="f_CodeExample" style="color: #333333;">1000000000</span><span class="f_CodeExample">&nbsp;*&nbsp;</span><span class="f_CodeExample" style="color: #333333;">1000000000</span><span class="f_CodeExample">;&nbsp;</span><span class="f_CodeExample" style="color: #808080;">//&nbsp;integral&nbsp;constant&nbsp;overflow</span>
<br><span class="f_CodeExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="f_CodeExample" style="color: #808080;">//&nbsp;m3&nbsp;=&nbsp;-1486618624</span></p>
</td>
</tr>
</table>
</div>
<p class="p_Text"><span class="f_Text">Integer constants in MQL5 have type </span><span class="f_Text" style="font-style: italic;">int</span><span class="f_Text">, so the multiplication of million by million is performed taking into account the range of this type, which is equal to INT_MAX (2147483647). The value 1000000000000000000 causes an overflow, and </span><span class="f_Text" style="font-style: italic;">m3</span><span class="f_Text"> gets the remainder after dividing this value by the range (more on this in the sidebar below).</span></p>
<p class="p_Text"><span class="f_Text">The fact that the receiving variable </span><span class="f_Text" style="font-style: italic;">m3</span><span class="f_Text"> has type </span><span class="f_Text" style="font-style: italic;">long</span><span class="f_Text"> does not mean that the values &#8203;&#8203;in the expression must be converted to it beforehand. This only happens at the moment of assignment. In order for the multiplication to be performed according to the rules of long, you need to somehow specify the type </span><span class="f_Text" style="font-style: italic;">long</span><span class="f_Text"> directly in the expression itself. This can be done with an explicit conversion or by using variables. In particular, obtaining the same product using a variable </span><span class="f_Text" style="font-style: italic;">m1</span><span class="f_Text"> of type </span><span class="f_Text" style="font-style: italic;">long</span><span class="f_Text"> (such as </span><span class="f_Text" style="font-style: italic;">m1 * m1</span><span class="f_Text">) leads to the correct result in </span><span class="f_Text" style="font-style: italic;">m2.</span></p>
<p class="p_Quote"><span class="f_Quote" style="font-weight: bold;">Signed and unsigned integers</span><br>
<span class="f_Quote" style="font-weight: bold;">&nbsp;</span><br>
<span class="f_Quote">Programs are not always written perfectly, with protection from all possible failures. Therefore, sometimes it happens that the integer number obtained during the calculations does not fit into the variable of the selected integer type. Then it gets the remainder of dividing this value by the maximum value (M) that can be written in the corresponding number of bytes (type size), plus 1. So for integer types with sizes from 1 to 4 bytes, M + 1 is, respectively, 256, 65536, 4294967296, and 18446744073709551616.</span><br>
<span class="f_Quote" style="font-weight: bold;">&nbsp;</span><br>
<span class="f_Quote">But there is a nuance for signed types. As we know, for signed numbers, the total range of values &#8203;&#8203;is divided approximately equally between positive and negative areas. Therefore, the new &quot;residual&quot; value may in 50% of cases exceed the positive or negative limit. In this case, the number turns into the &quot;opposite&quot;: it changes sign and ends up at a distance M from the original one.</span><br>
<span class="f_Quote" style="font-weight: bold;">&nbsp;</span><br>
<span class="f_Quote">It is important to understand that this transformation occurs only due to a different interpretation of the bit state in the internal representation, and the state itself is the same for signed and unsigned numbers.</span><br>
<span class="f_Quote" style="font-weight: bold;">&nbsp;</span><br>
<span class="f_Quote">Let's explain this with an example for the smallest integer types: </span><span class="f_Quote" style="font-style: italic;">char</span><span class="f_Quote"> and </span><span class="f_Quote" style="font-style: italic;">uchar</span><span class="f_Quote">.</span><br>
<span class="f_Quote" style="font-style: italic;">&nbsp;</span><br>
<span class="f_Quote">Since </span><span class="f_Quote" style="font-style: italic;">unsigned char</span><span class="f_Quote"> can store values &#8203;&#8203;from 0 to 255, 256 maps to 0, -1 maps to 255, 300 maps to 44, and so on. If we try to write 300 into a regular signed </span><span class="f_Quote" style="font-style: italic;">char</span><span class="f_Quote">, we also get 44, because 44 is in the range from 0 to 127 (the positive range of </span><span class="f_Quote" style="font-style: italic;">char</span><span class="f_Quote">). However, if you set the variables </span><span class="f_Quote" style="font-style: italic;">char</span><span class="f_Quote"> and </span><span class="f_Quote" style="font-style: italic;">uchar</span><span class="f_Quote"> to 3000, the picture will be different. The remainder of 3000 divided by 256 is 184. It ends up in </span><span class="f_Quote" style="font-style: italic;">uchar</span><span class="f_Quote"> unchanged. However, for </span><span class="f_Quote" style="font-style: italic;">char</span><span class="f_Quote">, the same combination of bits results in -72. It is easy to check that 184 and -72 differ by 256.</span></p>
<p class="p_Text"><span class="f_Text">In the following example, it is easy to spot the problem thanks to the compiler warning.</span></p>
<div style="text-align: left; text-indent: 0; line-height: 1.0; page-break-inside: avoid; page-break-after: avoid; border-color: #d8dfea; border-style: solid; border-width: thin; background: #fbf9f5; padding: 0 0 0 0; margin: 2px 17px 2px 17px;"><table cellspacing="0" cellpadding="3" border="0" style="text-align: justify;border:none; border-spacing:0;">
<tr>
<td style="vertical-align:top; padding:3px; border:none"><p class="p_CodeExample" style="page-break-inside: avoid; page-break-after: avoid;"><span class="f_CodeExample" style="color: #0000ff;">char</span><span class="f_CodeExample">&nbsp;</span><span class="f_CodeExample" style="color: #333333;">c</span><span class="f_CodeExample">&nbsp;=&nbsp;</span><span class="f_CodeExample" style="color: #333333;">3000</span><span class="f_CodeExample">;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="f_CodeExample" style="color: #808080;">//&nbsp;truncation&nbsp;of&nbsp;constant&nbsp;value</span>
<br><span class="f_CodeExample" style="color: #0000ff;">Print</span><span class="f_CodeExample">(</span><span class="f_CodeExample" style="color: #333333;">c</span><span class="f_CodeExample">);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="f_CodeExample" style="color: #808080;">//&nbsp;-72</span>
<br><span class="f_CodeExample" style="color: #0000ff;">uchar</span><span class="f_CodeExample">&nbsp;</span><span class="f_CodeExample" style="color: #333333;">uc</span><span class="f_CodeExample">&nbsp;=&nbsp;</span><span class="f_CodeExample" style="color: #333333;">3000</span><span class="f_CodeExample">;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="f_CodeExample" style="color: #808080;">//&nbsp;truncation&nbsp;of&nbsp;constant&nbsp;value</span>
<br><span class="f_CodeExample" style="color: #0000ff;">Print</span><span class="f_CodeExample">(</span><span class="f_CodeExample" style="color: #333333;">uc</span><span class="f_CodeExample">);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="f_CodeExample" style="color: #808080;">//&nbsp;184</span></p>
</td>
</tr>
</table>
</div>
<p class="p_Text"><span class="f_Text">However, if you get an extra large number during the calculation, there will be no warning.</span></p>
<div style="text-align: left; text-indent: 0; line-height: 1.0; page-break-inside: avoid; page-break-after: avoid; border-color: #d8dfea; border-style: solid; border-width: thin; background: #fbf9f5; padding: 0 0 0 0; margin: 2px 17px 2px 17px;"><table cellspacing="0" cellpadding="3" border="0" style="text-align: justify;border:none; border-spacing:0;">
<tr>
<td style="vertical-align:top; padding:3px; border:none"><p class="p_CodeExample" style="page-break-inside: avoid; page-break-after: avoid;"><span class="f_CodeExample" style="color: #0000ff;">char</span><span class="f_CodeExample">&nbsp;</span><span class="f_CodeExample" style="color: #333333;">c55</span><span class="f_CodeExample">&nbsp;=&nbsp;</span><span class="f_CodeExample" style="color: #333333;">55</span><span class="f_CodeExample">;</span>
<br><span class="f_CodeExample" style="color: #0000ff;">char</span><span class="f_CodeExample">&nbsp;</span><span class="f_CodeExample" style="color: #333333;">sm</span><span class="f_CodeExample">&nbsp;=&nbsp;</span><span class="f_CodeExample" style="color: #333333;">c55</span><span class="f_CodeExample">&nbsp;*&nbsp;</span><span class="f_CodeExample" style="color: #333333;">c55</span><span class="f_CodeExample">;&nbsp;&nbsp;</span><span class="f_CodeExample" style="color: #808080;">//&nbsp;ok!&nbsp;</span>
<br><span class="f_CodeExample" style="color: #0000ff;">Print</span><span class="f_CodeExample">(</span><span class="f_CodeExample" style="color: #333333;">sm</span><span class="f_CodeExample">);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="f_CodeExample" style="color: #808080;">//&nbsp;3025&nbsp;-&gt;&nbsp;-47</span>
<br><span class="f_CodeExample" style="color: #0000ff;">uchar</span><span class="f_CodeExample">&nbsp;</span><span class="f_CodeExample" style="color: #333333;">um</span><span class="f_CodeExample">&nbsp;=&nbsp;</span><span class="f_CodeExample" style="color: #333333;">c55</span><span class="f_CodeExample">&nbsp;*&nbsp;</span><span class="f_CodeExample" style="color: #333333;">c55</span><span class="f_CodeExample">;&nbsp;</span><span class="f_CodeExample" style="color: #808080;">//&nbsp;ok!</span>
<br><span class="f_CodeExample" style="color: #0000ff;">Print</span><span class="f_CodeExample">(</span><span class="f_CodeExample" style="color: #333333;">um</span><span class="f_CodeExample">);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="f_CodeExample" style="color: #808080;">//&nbsp;3025&nbsp;-&gt;&nbsp;209</span></p>
</td>
</tr>
</table>
</div>
<p class="p_Text"><span class="f_Text">A similar effect can occur when signed and unsigned integer numbers of the same size are used in the same expression since the signed operand is converted to unsigned. For example:</span></p>
<div style="text-align: left; text-indent: 0; line-height: 1.0; page-break-inside: avoid; page-break-after: avoid; border-color: #d8dfea; border-style: solid; border-width: thin; background: #fbf9f5; padding: 0 0 0 0; margin: 2px 17px 2px 17px;"><table cellspacing="0" cellpadding="3" border="0" style="text-align: justify;border:none; border-spacing:0;">
<tr>
<td style="vertical-align:top; padding:3px; border:none"><p class="p_CodeExample" style="page-break-inside: avoid; page-break-after: avoid;"><span class="f_CodeExample" style="color: #0000ff;">uint</span><span class="f_CodeExample">&nbsp;</span><span class="f_CodeExample" style="color: #333333;">u</span><span class="f_CodeExample">&nbsp;=&nbsp;</span><span class="f_CodeExample" style="color: #333333;">11</span><span class="f_CodeExample">;</span>
<br><span class="f_CodeExample" style="color: #0000ff;">int</span><span class="f_CodeExample">&nbsp;</span><span class="f_CodeExample" style="color: #333333;">i</span><span class="f_CodeExample">&nbsp;=&nbsp;-</span><span class="f_CodeExample" style="color: #333333;">49</span><span class="f_CodeExample">;</span>
<br><span class="f_CodeExample" style="color: #0000ff;">Print</span><span class="f_CodeExample">(</span><span class="f_CodeExample" style="color: #333333;">i</span><span class="f_CodeExample">&nbsp;+&nbsp;</span><span class="f_CodeExample" style="color: #333333;">i</span><span class="f_CodeExample">);&nbsp;</span><span class="f_CodeExample" style="color: #808080;">//&nbsp;-98</span>
<br><span class="f_CodeExample" style="color: #0000ff;">Print</span><span class="f_CodeExample">(</span><span class="f_CodeExample" style="color: #333333;">u</span><span class="f_CodeExample">&nbsp;+&nbsp;</span><span class="f_CodeExample" style="color: #333333;">i</span><span class="f_CodeExample">);&nbsp;</span><span class="f_CodeExample" style="color: #808080;">//&nbsp;4294967258&nbsp;=&nbsp;4294967296&nbsp;-&nbsp;38</span></p>
</td>
</tr>
</table>
</div>
<p class="p_Text"><span class="f_Text">When two negative integers add up, we get the expected result. The second expression maps the sum of -38 to the &quot;opposite&quot; unsigned number 4294967258.</span></p>
<p class="p_Quote"><span class="f_Quote">Mixing signed and unsigned types in the same expression is not recommended because of these potential issues.</span></p>
<p class="p_Text"><span class="f_Text">Besides that, if we subtract something from an unsigned integer, we need to make sure that the result doesn't come out negative. Otherwise, it will be converted to a positive number and can distort the idea of the algorithm, in particular, the idea of the </span><span class="f_Text" style="font-style: italic;"><a href="2_7_6_statements_while.htm" class="topiclink">while</a></span><span class="f_Text"><a href="2_7_6_statements_while.htm" class="topiclink"> loop</a> which checks the variable for the &quot;greater than or equal to zero&quot; condition: since unsigned numbers are always non-negative, we can easily get an infinite loop, i.e. a program hang.</span></p>

</div>

</body>
</html>
